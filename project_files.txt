Collecting project files from: /home/jedre/gitrepos/Collabothon_AIHolics
Mode: full | Max bytes per file: 200000 (0 = no limit)

===== FILE: ./app/banking.py =====

```python
from sqlalchemy.orm import Session
from sqlalchemy import select
from .models import User, Account


def seed_data(db: Session):
    """Dodaje podstawowego użytkownika i konto, jeśli baza jest pusta."""
    if db.execute(select(User)).first():
        return

    user = User(id="user-1", name="Jan Kowalski", phone="+48123123123")
    db.add(user)

    acc = Account(
        id="acc-1",
        user_id="user-1",
        iban="PL00123456789012345678901234",
        balance=2500.00,
        currency="PLN",
    )
    db.add(acc)

    db.commit()


def get_user(db: Session, user_id: str):
    stmt = select(User).where(User.id == user_id)
    return db.execute(stmt).scalar_one_or_none()


def get_account_for_user(db: Session, user_id: str):
    stmt = select(Account).where(Account.user_id == user_id)
    return db.execute(stmt).scalar_one_or_none()


def perform_transfer(db: Session, user_id: str, amount: float) -> Account:
    """
    Wykonuje przelew (odejmuje saldo).
    Waliduje środki i kwotę.
    """
    account = get_account_for_user(db, user_id)
    if not account:
        raise ValueError("Brak konta dla użytkownika.")

    if amount <= 0:
        raise ValueError("Kwota przelewu musi być dodatnia.")

    if account.balance < amount:
        raise ValueError("Niewystarczające środki na koncie.")

    account.balance -= amount
    db.commit()
    db.refresh(account)

    return account

```

===== FILE: ./app/config.py =====

```python
import os
from dotenv import load_dotenv

load_dotenv()

GROQ_API_KEY = os.getenv("GROQ_API_KEY")
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./app.db")

```

===== FILE: ./app/db.py =====

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

from .config import DATABASE_URL

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in DATABASE_URL else {},
)

SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)

Base = declarative_base()


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

```

===== FILE: ./app/llm.py =====

```python
from groq import Groq
from .config import GROQ_API_KEY

if not GROQ_API_KEY:
    raise RuntimeError("Brak GROQ_API_KEY w .env – ustaw go przed uruchomieniem.")

client = Groq(api_key=GROQ_API_KEY)

DEFAULT_MODEL = "llama-3.1-8b-instant"


def detect_intent(message: str) -> str:
    msg = message.lower()
    if "saldo" in msg or "stan konta" in msg:
        return "check_balance"
    if "przelew" in msg or "przelać" in msg:
        return "make_transfer"
    return "other"


def ask_llm(message: str, context: str) -> str:
    prompt = (
        "Jesteś wirtualnym asystentem bankowym. "
        "Odpowiadasz krótko, jasno, po polsku.\n\n"
        f"Kontekst klienta:\n{context}\n\n"
        f"Pytanie klienta: {message}\n"
    )

    completion = client.chat.completions.create(
        model=DEFAULT_MODEL,
        messages=[
            {
                "role": "system",
                "content": "Jesteś asystentem bankowym mówiącym po polsku.",
            },
            {"role": "user", "content": prompt},
        ],
        temperature=0.3,
    )

    content = completion.choices[0].message.content or ""
    return content.strip()

```

===== FILE: ./app/main.py =====

```python
import re
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session

from .db import Base, engine, get_db
from . import banking
from .schemas import ChatRequest, ChatResponse
from .llm import detect_intent, ask_llm

Base.metadata.create_all(bind=engine)

app = FastAPI(title="Collab Voice Assistant")


def extract_amount(message: str) -> float:
    """
    Bardzo prosty parser kwoty z tekstu.
    Szuka pierwszej liczby w tekście:
    - 100
    - 100,50
    - 100.50
    """
    m = re.search(r"(\d+[,.]?\d*)", message.replace(" ", ""))
    if not m:
        return 0.0
    try:
        return float(m.group(1).replace(",", "."))
    except ValueError:
        return 0.0


@app.on_event("startup")
def startup():
    with next(get_db()) as db:
        banking.seed_data(db)


@app.get("/health")
def health():
    return {"status": "ok"}


@app.post("/assistant/chat", response_model=ChatResponse)
def assistant_chat(req: ChatRequest, db: Session = Depends(get_db)):
    intent = detect_intent(req.message)
    user = banking.get_user(db, req.user_id)
    account = banking.get_account_for_user(db, req.user_id)

    # ---------- INTENCJA: PRZELEW ----------
    if intent == "make_transfer":
        if account is None:
            return ChatResponse(
                reply="Nie znaleziono konta dla tego użytkownika.",
                intent=intent,
            )

        amount = extract_amount(req.message)
        if amount <= 0:
            return ChatResponse(
                reply="Nie udało mi się rozpoznać poprawnej kwoty przelewu.",
                intent=intent,
            )

        try:
            updated = banking.perform_transfer(db, req.user_id, amount)
        except ValueError as e:
            # np. niewystarczające środki
            return ChatResponse(reply=str(e), intent=intent)

        reply = (
            f"Przelew na kwotę {amount:.2f} {updated.currency} został wykonany. "
            f"Twoje aktualne saldo to {updated.balance:.2f} {updated.currency} "
            f"na koncie {updated.iban}."
        )
        return ChatResponse(reply=reply, intent=intent)

    # ---------- INTENCJA: SPRAWDZENIE SALDA ----------
    if intent == "check_balance":
        if account is None:
            reply = "Nie znaleziono konta dla tego użytkownika."
        else:
            reply = (
                f"Twoje aktualne saldo wynosi {account.balance:.2f} {account.currency} "
                f"na koncie {account.iban}."
            )
        return ChatResponse(reply=reply, intent=intent)

    # ---------- POZOSTAŁE PYTANIA → LLM ----------
    context = ""
    if user:
        context += f"Użytkownik: {user.name}\n"
    if account:
        context += f"Saldo: {account.balance:.2f} {account.currency} na koncie {account.iban}\n"

    reply = ask_llm(req.message, context)
    return ChatResponse(reply=reply, intent=intent)

```

===== FILE: ./app/models.py =====

```python
from sqlalchemy import String, Float
from sqlalchemy.orm import Mapped, mapped_column

from .db import Base


class User(Base):
    __tablename__ = "users"

    id: Mapped[str] = mapped_column(String, primary_key=True, index=True)
    name: Mapped[str] = mapped_column(String, nullable=False)
    phone: Mapped[str] = mapped_column(String, nullable=False)


class Account(Base):
    __tablename__ = "accounts"

    id: Mapped[str] = mapped_column(String, primary_key=True, index=True)
    user_id: Mapped[str] = mapped_column(String, nullable=False)
    iban: Mapped[str] = mapped_column(String, nullable=False)
    balance: Mapped[float] = mapped_column(Float, nullable=False)
    currency: Mapped[str] = mapped_column(String, default="PLN")

```

===== FILE: ./app/schemas.py =====

```python
from pydantic import BaseModel
from typing import Optional


class ChatRequest(BaseModel):
    user_id: str
    message: str


class ChatResponse(BaseModel):
    reply: str
    intent: Optional[str]


class UserOut(BaseModel):
    id: str
    name: str
    phone: str


class AccountOut(BaseModel):
    id: str
    user_id: str
    iban: str
    balance: float
    currency: str

```

===== FILE: ./cli_client.py =====

```python
import httpx
import asyncio

API = "http://127.0.0.1:8000/assistant/chat"
USER = "user-1"


async def main():
    print("Asystent bankowy (CLI). Napisz 'exit' aby wyjść.\n")

    async with httpx.AsyncClient() as client:
        while True:
            msg = input("Ty: ")
            if msg.lower() == "exit":
                break

            resp = await client.post(API, json={"user_id": USER, "message": msg})
            data = resp.json()

            print(f"Asystent ({data['intent']}): {data['reply']}\n")


if __name__ == "__main__":
    asyncio.run(main())

```

===== FILE: ./requirements.txt =====

```
fastapi
uvicorn[standard]
sqlalchemy
pydantic
python-dotenv
groq
httpx

```

===== FILE: ./voice_agent.py =====

```python
import asyncio
import httpx
import speech_recognition as sr
import pyttsx3

API = "http://127.0.0.1:8000/assistant/chat"
USER = "user-1"


def init_tts():
    engine = pyttsx3.init()
    # Możesz tu dopasować głos / szybkość
    rate = engine.getProperty("rate")
    engine.setProperty("rate", rate - 20)  # trochę wolniej
    return engine


async def send_to_backend(text: str) -> str:
    async with httpx.AsyncClient() as client:
        resp = await client.post(API, json={"user_id": USER, "message": text})
        resp.raise_for_status()
        data = resp.json()
        print(f"Asystent ({data['intent']}): {data['reply']}\n")
        return data["reply"]


async def main():
    recognizer = sr.Recognizer()
    tts_engine = init_tts()

    print("Asystent bankowy (VOICE). Powiedz 'koniec' żeby zakończyć.\n")

    while True:
        # --- NAGRYWANIE GŁOSU ---
        with sr.Microphone() as source:
            print("Nasłuchuję... (mów po polsku)")
            recognizer.adjust_for_ambient_noise(source, duration=0.5)
            audio = recognizer.listen(source)

        try:
            # --- STT: MOWA -> TEKST ---
            text = recognizer.recognize_google(audio, language="pl-PL")
            text = text.strip()
            print(f"Ty (rozpoznane): {text}")

        except sr.UnknownValueError:
            print("Nie zrozumiałem, powtórz proszę.\n")
            continue
        except sr.RequestError as e:
            print(f"Błąd usługi rozpoznawania mowy: {e}")
            break

        if text.lower() in ["koniec", "exit", "zakończ", "stop"]:
            print("Kończę rozmowę.")
            break

        # --- WYŚLIJ DO BACKENDU ---
        reply = await send_to_backend(text)

        # --- TTS: TEKST -> MOWA ---
        tts_engine.say(reply)
        tts_engine.runAndWait()


if __name__ == "__main__":
    asyncio.run(main())

```

